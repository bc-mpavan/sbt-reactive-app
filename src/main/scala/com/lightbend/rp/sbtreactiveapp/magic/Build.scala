/*
 * Copyright 2017 Lightbend, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.lightbend.rp.sbtreactiveapp.magic

import sbt.{ Attributed, File, IO }
import scala.collection.JavaConverters._
import java.net.URL
import com.typesafe.config.{ Config, ConfigFactory }

object Build {
  def annotate(prependInclude: Boolean, unmanagedConfigName: String, config: String): String =
    s"""|# Generated by sbt-reactive-app. To disable this, set the `prependRpConf` sbt key to `""`.
        |
        |""".stripMargin +
      (if (prependInclude) s"""include "$unmanagedConfigName"""" else "") +
      s"""|
          |$config""".stripMargin

  def withHeader(comment: String, config: String): String =
    s"""|# $comment
        |
        |$config""".stripMargin

  def extractRpToolingConf(
    managedConfigNames: Seq[String],
    dependencyClasspath: Seq[Attributed[File]],
    prependInclude: Boolean,
    unmanagedConfigName: String): String = {
    val dependencyClassLoader = new java.net.URLClassLoader(dependencyClasspath.files.map(_.toURI.toURL).toArray)

    val managedConfigs: List[URL] =
      managedConfigNames
        .flatMap(dependencyClassLoader.findResources(_).asScala)
        .toList

    annotate(
      prependInclude,
      unmanagedConfigName,
      (managedConfigs
        .foldLeft(Seq.empty[String]) {
          case (accum, conf) =>
            accum :+ withHeader(conf.toString, IO.readLinesURL(conf).mkString(IO.Newline))
        }).mkString(IO.Newline))
  }

  def makeConfig(dependencyClasspath: Seq[File]): Config = {
    val dependencyClassLoader = new java.net.URLClassLoader(dependencyClasspath.map(_.toURI.toURL).toArray)
    ConfigFactory.load(dependencyClassLoader)
  }
}
